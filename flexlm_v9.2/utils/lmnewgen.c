/*****************************************************************************

	    COPYRIGHT (c) 1988, 2003 by Macrovision Corporation.
	This software has been provided pursuant to a License Agreement
	containing restrictions on its use.  This software contains
	valuable trade secrets and proprietary information of 
	Macrovision Corporation and is protected by law.  It may 
	not be copied or distributed in any form or medium, disclosed 
	to third parties, reverse engineered or used in any manner not 
	provided for in said License Agreement except with the prior 
	written authorization from Macrovision Corporation.

 *****************************************************************************/
/*
 *	Module: $Id: lmnewgen.c,v 1.55 2003/01/31 17:09:44 kmaclean Exp $
 *
 *	This is linked with lmcode.o (generated by lmrand1) to make lmnewgen
 *	
 *	lmcode.c contains the SEEDs and other info from lm_code.h
 *
 *	lmnewgen generates:
 *		lm_new.c
 *		lmprikey.h
 *	lm_new.c contains code that:
 *		1) is called by lc_new_job, and initializes VENDORCODE
 *		   Note that the public-key is in here, although it's
 *		   not the "real" public-key -- it's obfuscated.  The
 *		   obfuscation code is in l_prikey.c, call L_G and L_F.
 *		2) handshake code called by l_handshake.c
 *	Seeds3 and 4 are only used as seeds to random number generators.
 *	It's impossible (and must remain impossible) to extract seeds 3
 *	and 4 from a binary, since they're not there.  They're in lmnewgen,
 *	but this must never be shipped.  It's only used to generate 
 *	code.
 *
 */

#include "lmachdep.h"
#include "lmclient.h"
#include "l_prot.h"
#include "l_strkey.h"
#include "lgetattr.h"
#include "time.h"
#include "stdio.h"
#include "sys/types.h"
#include "sys/stat.h"
#include "l_rand.h"
#if defined(UNIX) && defined(ANSI)
#include <unistd.h>
#endif
#include "l_mddl.h"
#include "l_borrow.h"
#ifndef RELEASE_VERSION
static char * readable_client;
#endif
#ifdef RELEASE_VERSION
#define L_INTERNAL_VAR(x, y) (y)
#else
#define L_INTERNAL_VAR(x, y) (x)
#endif

LM_HANDLE *lm_job; /* purely to allow linking with functions that refer to it */
int (*L_NEW_JOB)(); /* to allow linking with liblmgr_as.a */

/***********************************************************************
 * Local functions
 ************************************************************************/
static void do_real(void );
static void uniqcode(void );
static void do_small_flag(void);
static void do_handshake(char *charptrname, char *idxname, char *switchname);


FILE *	ofp = NULL;
FILE *	fpVar = NULL;
FILE *	fpFunc = NULL;
#define	BUF_SIZE		10240
char	vBuf[BUF_SIZE] = {'\0'};
char	fBuf[BUF_SIZE] = {'\0'};
char *	pvBuf = vBuf;
char *	pfBuf = fBuf;
#define VAR_TEMP_FILENAME	"vartemp.tmp"
#define FUNC_TEMP_FILENAME	"functemp.tmp"
#define CLEARV	memset(vBuf, 0, sizeof(vBuf))
#define CLEARF	memset(fBuf, 0, sizeof(fBuf))

#define VKEY5	l_index1_cf41383
char *initbuf;
char *initbufp;

static int cryptnum = 4;
static char cryptlabel[10];
extern int keysize;
extern VENDORCODE vendorkeys[];
extern char *vendor_name;
int key5_order[4];
int reorder_arr[L_BBLOCK_SIZE];
unsigned long key5_uniqx;
extern int l_borrow_ok;
static void do_borrow( char *, char *, char *);
static void do_constant(int val, char *, char *);
static void rand_arr(int *ret, int size);
char * cryptcode(char *, char *, char *, int, int , int);
static void borrow_cryptbegin( char *, char *, char *, int, int);
static int lmrands[3];
static int set_lm_case(void);
int borrow_seeds[3];
int borrow_session_seeds[3];

#define MAXVARNAME 80

int numwords;
char *words[] = {
	"var",
	"func",
	"buf",
	"buff",
	"bufg",
	"counter",
	"ctr",
	"idx",
	"index",
	"counters",
	"reg",
	"registers",
	"indexes" };


static char *header =
"/******************************************************************************\n\n" \
COPYRIGHT_STRING(1988) "\n\
\tThis software has been provided pursuant to a License Agreement\n\
\tcontaining restrictions on its use.  This software contains\n\
\tvaluable trade secrets and proprietary information of \n\
\tMacrovision Corporation and is protected by law.  It may \n\
\tnot be copied or distributed in any form or medium, disclosed \n\
\tto third parties, reverse engineered or used in any manner not \n\
\tprovided for in said License Agreement except with the prior \n\
\twritten authorization from Macrovision Corporation.\n\
****************************************************************************/\n\
#define LM_PUBKEYS 	3\n\
#define LM_MAXPUBKEYSIZ 40\n\
\n\
typedef struct _pubkeyinfo {\n\
		    int pubkeysize[LM_PUBKEYS];\n\
		    unsigned char pubkey[LM_PUBKEYS][LM_MAXPUBKEYSIZ];\n\
		    int (*pubkey_fptr)();\n\
		    int strength;\n\
		    int sign_level;\n\
} LM_VENDORCODE_PUBKEYINFO;\n\
#define LM_MAXSIGNS 	4   /* SIGN=, SIGN2=, SIGN3=, SIGN4= */\n\
\n\
\n\
typedef struct _vendorcode {\n\
		    short type;	   \n\
		    unsigned long data[2]; \n\
		    unsigned long keys[4]; \n\
		    short flexlm_version;\n\
		    short flexlm_revision;\n\
		    char flexlm_patch[2];\n\
#define LM_MAX_BEH_VER 4 \n\
		    char behavior_ver[LM_MAX_BEH_VER + 1];\n\
		    unsigned long crokeys[2]; \n\
		    int signs; \n\
		    int strength; \n\
		    int sign_level;\n\
		    LM_VENDORCODE_PUBKEYINFO pubkeyinfo[LM_MAXSIGNS];\n\
\n\
			  } VENDORCODE;\n\
extern char *(*l_borrow_dptr)(void *, char *, int, int);\n\
\n\
\n";

char tempidxname[MAXVARNAME + 1];
char define32[MAXVARNAME + 1];
char countervar[MAXVARNAME + 1];

static void random_garbage lm_args((lm_noargs));
static unsigned int val lm_args((lm_noargs));
static void randvarname lm_args((char *, char *));
static unsigned int our_rand lm_args(( int ));
static void do_ulong lm_args(( unsigned long , char *, int ));
static void VKEY5 lm_args((char *, VENDORCODE *));
static void key5 lm_args(( VENDORCODE *));
static void do_string lm_args(( char *, char *, int, int));
char bytenames[256][MAXVARNAME];
char byteassign[256][MAXVARNAME];
char key5_fname[MAXVARNAME];
char countername[MAXVARNAME + 1];
char outfile[50];
static int small_flag = 0;
extern unsigned long seed1;
extern unsigned long seed2;
extern unsigned long seed3;
extern unsigned long seed4;
extern unsigned long lmseed1;

extern unsigned long lmseed2;
extern unsigned long lmseed3;
extern int lm_sign_level;
unsigned int croseeds[LM_MAXSIGNS][3];
extern int pubkey_strength;
char *l_api_prefix;
static char vname[MAX_DAEMON_NAME + 1]; /* buffer must be big enough */
int borrow_fixed = 0;
#if defined(PC) && !defined(TARGETVXWORKS)
static void makecpuid( LM_HANDLE *, FILE *);
#endif
int lm_case; /* See machind/lm_code2.h for definitions of the cases */

#ifdef RELEASE_VERSION
#define DEVCOMMENT(str) ("")
#else
#define DEVCOMMENT(str) str
#endif

int numvars;
VENDORCODE public;

/***********************************************************************
 * Print the usage message and exit
 ************************************************************************/
static void usage(char * name)
{
	fprintf(stderr,"Usage: %s vendor_name [-o outputfile] [-bfixed] [-nocro] [-small] [-api_prefix name]\n");
	fprintf(stderr,"  -o outputfile    -- Send out put to the file. The default is lm_new.c\n");    
	fprintf(stderr,"  -bfixed          -- Borrow fixed\n");
	fprintf(stderr,"  -nocro           -- Disable CRO\n");
	/*	
	 * kmaclean 1/21/03
	 * Don't know what these options do so don't put them in the usage message.
	 * Since this goes to customers I don't want them calling asking what these do
	 *  
	fprintf(stderr,"  -small           -- \n");
	fprintf(stderr,"  -api_prefix name -- \n");
 	*/ 
	fprintf(stderr,"  -h               -- Display this help message\n");

	exit (1);
}	

/***********************************************************************
 * Main
 ************************************************************************/
int main(int argc, char **argv)
{
  int i;
  struct stat st;
  LM_HANDLE *job;
  char *f_argv[30]; /* argv arguments for filter_gen */
  char argv_strs[30][30];
  VENDORCODE vkey;
  extern char *l_appfile;
  int nocro = 0;
#define NEWSEEDSIZ (7 * 4)
  unsigned char newseeds[NEWSEEDSIZ];


/*
 *	Initialize vars
 */
#ifndef RELEASE_VERSION
	readable_client = l_real_getenv("L_READABLE");
#endif
	memset(vname, 0, sizeof(vname));
	memset(croseeds, 0, sizeof(croseeds));
	strcpy(vname, vendor_name);
	strcpy(outfile, "lm_new.c");
	lm_case = set_lm_case();

	for (i = 1; i < argc; i++)
	{
		if (!strcmp(argv[i], "-h")) 		
			usage(argv[0]);
		else if (!strcmp(argv[i], "-bfixed")) 		
		{
			borrow_fixed = 1;
		}
		else if (!strcmp(argv[i], "-o")) 		
		{
			l_appfile = argv[++i];
			strcpy(outfile, l_appfile);
			continue;
		}
		else if (!strcmp(argv[i], "-nocro")) 		
		{
			nocro = 1;
		}
		else if (!strcmp(argv[i], "-small"))
			small_flag = 1;
		else if (!strcmp(argv[i], "-api_prefix")) 
		{
			i++;
			if (i >= argc)
			{
				fprintf(stderr, "Error:  -api_prefix needs an arg\n");
				exit(1);
			}
			l_api_prefix = argv[i];
			sprintf(outfile, "%s.c", l_api_prefix);
			l_appfile = outfile;
		}
		else if ( i == 1 )
		{
			/* kmaclean  1/31/03
			 * it's the first arg and we don't recognize it.
			 * It's probably the vendor name which is no longer used but is 
			 * still in many makefiles. This error checking was added because
			 * of the problem with the demo vendor keys a while back */
			if ( strcmp(argv[i], vendor_name) != 0 )
			{
				/* the first arg is the daemon name */
				fprintf(stderr,"Vendor name on command line (%s) does not match \n",argv[1]);
				fprintf(stderr,"vendor name (%s) that lmnewgen was built for.\n", vendor_name);
				fprintf(stderr," Check lm_code.h and lmcode.o \n");
				exit (1);
			}
		}
		else
		{
			fprintf(stderr, "Unknown argument %s\n", argv[i]);
			usage(argv[0]);
		}
	}  /* for */

	if (lc_init(0, vendor_name, &vendorkeys[0], &job))
	{
		fprintf(stderr, "lc_init failed: %s\n", lc_errstring(job));
		exit(1);
	}
	l_genrand(job, lmseed1, lmseed2, lmseed3, NEWSEEDSIZ, newseeds);
	lc_free_job(job);
	for (i = 0;i < 4; i++)
	{
		if (lm_case == 7 || lm_case == 8) /* new with v8.1+ */
		{
			seed1 |= newseeds[i] << (i * 8);
			seed2 |= newseeds[i+4] << (i * 8);
			seed3 |= newseeds[i+8] << (i * 8);
			seed4 |= newseeds[i+12] << (i * 8);
		}
		if (lm_case == 1 || lm_case == 2) /* Upgrade pre7.2 to 8.1+*/
		{
			seed3 |= newseeds[i+8] << (i * 8);
			seed4 |= newseeds[i+12] << (i * 8);
		}
		croseeds[0][0] |= (newseeds[i+16] << (i * 8));
		croseeds[0][1] |= (newseeds[i+20] << (i * 8));
		croseeds[0][2] |= (newseeds[i+24] << (i * 8));
	}
	if (lm_case == 7 || lm_case == 8) /* new with v8.1+ */
	{
		vendorkeys[0].data[0] ^= seed1;
		vendorkeys[0].data[1] ^= seed2;
	}
	if (!(ofp = fopen("lmseeds.h", "w")))
	{
		perror("Can't write lmseeds.h file, exiting");
		exit(1);
	}
	fprintf(ofp, "\n\
#undef ENCRYPTION_SEED1\n\
#undef ENCRYPTION_SEED2\n\
#undef ENCRYPTION_SEED3\n\
#undef ENCRYPTION_SEED4\n\
#define ENCRYPTION_SEED1 0x%08X\n\
#define ENCRYPTION_SEED2 0x%08X\n\
#define ENCRYPTION_SEED3 0x%08X\n\
#define ENCRYPTION_SEED4 0x%08X\n\
",
		seed1, seed2, seed3, seed4);
	fclose(ofp);

 	memcpy(&vkey, &vendorkeys[0], sizeof(VENDORCODE));
	if (!(ofp = fopen(outfile, "w")))
	{
		perror("Can't open output file, exiting");
		exit(1);
	}
	if (lc_init(0, vendor_name, &vendorkeys[0], &job))
        {
                fprintf(stderr, "lc_init failed: %s\n", lc_errstring(job));
                exit(1);
        }
	else
	{
		int admin = l_getattr(job, LMADMIN_API) == LMADMIN_API_VAL;
		int real_keys = l_getattr(job, NO_EXPIRE) == NO_EXPIRE_VAL;
		int pubkey = l_getattr(job, LM_PUBKEY_ATTR) == 
						LM_PUBKEY_ATTR_VAL;

		
		if (!admin && !real_keys)
		{
			small_flag = 1;
		}
		if (pubkey && (pubkey_strength <= LM_STRENGTH_DEFAULT) &&
			(!admin && real_keys))
		{
			if (getenv("FLEXLM_NO_CRO") || nocro)
			{
				fprintf(stderr, 
"Warning:  CRO purchased, but no enabled\n\
proceeding because of override...\n");
			}
			else
			{
				fprintf(stderr, 
"Warning:  CRO purchased, but not enabled.\n\
We suggest setting LM_STRENGTH in lm_code.h in machind to one of the\n\
CRO settings.\n\
To override this, set the FLEXLM_NO_CRO environment variable to 1\n\
or change the makefile so lmnewgen is called with -nocro.\n");
				exit(1);
			}
		}
		else if (real_keys && !pubkey && 
				(pubkey_strength > LM_STRENGTH_DEFAULT) )
		{
			fprintf(stderr, 
"Error:  CRO not purchased, but LM_STRENGTH set to CRO value.\n\
You must reset LM_STRENGTH in lm_code.h to non CRO value.\n");
			exit(1);
		}
		else if (real_keys && !pubkey && vkey.crokeys[0])
		{
			if (getenv("FLEXLM_NO_CRO") || nocro)
			{
				fprintf(stderr, 
"Warning:  CRO disabled for this platform,\n\
proceeding because of override...\n");
			}
			else
			{
				fprintf(stderr, 
"Warning:  CRO enabled for some platforms, but not this platform\n\
This breaks licensing platform independence, and can cause licensing\n\
failures.\n\
To override this, set the FLEXLM_NO_CRO environment variable to 1\n\
or change the makefile so lmnewgen is called with -nocro.\n");
				exit(1);
			}
		}
		if (real_keys && pubkey && !lm_sign_level)
		{
			fprintf(stderr, "\n\
ERROR: CRO indicated, but LM_SIGN_LEVEL set to 0\n\
LM_SIGN_LEVEL must be > 0\n\
Please edit lm_code.h and rebuild, exiting\n\n");
			exit(1);
		}
		if (real_keys)
		{
			if (!l_reasonable_seed(seed3) || 
				!l_reasonable_seed(seed4) ||
				!l_reasonable_seed(lmseed1) ||
				!l_reasonable_seed(lmseed2) ||
				!l_reasonable_seed(lmseed3))
			{

				fprintf(stderr, 
			"ENCRYPTION_SEEDs or LM_SEEDs in lm_code.h\n");
				fprintf(stderr, 
			"are non-unique.  Set them to 32-bit values\n");
				fprintf(stderr, 
			"that you make up, and never change them.\n");
				fprintf(stderr, 
			"And make sure you keep safe copies.\n");
				fprintf(stderr, 
	"You can use \"lmrand1 -seed\" to make up numbers if you prefer.\n");
				if (getenv("FLEXLM_SEED_OVERRIDE"))
					fprintf(stderr, "Overridding...\n");
				else
				{
					fprintf(stderr, "Exiting.\n");
					exit(1);
				}
			}
				

		}
	}
	if (lm_sign_level == LM_SIGN2)
	{
		croseeds[1][0] = seed3;
		croseeds[1][1] = seed4;
	}
	l_gen_pkey_headers(croseeds, pubkey_strength, &public, vname);

/*
 *	file header
 */

	fprintf(ofp, header, LM_PUBKEYS, LM_PUBKEYS, LM_MAXPUBKEYSIZ);
		
#ifdef PC
        fprintf(ofp, "#pragma optimize(\"\", off)\n");
#endif
	if (pubkey_strength>= LM_STRENGTH_PUBKEY)
		fprintf(ofp, "extern int l_pubkey_verify();\n");
#ifdef ANSI
	fputs("#include <string.h>\n", ofp);
	fputs("#include <time.h>\n", ofp);
#endif

/*
 *	The rest...
 */

	if (!l_api_prefix)
	{
		if (small_flag) 
			do_small_flag();
		else 
			do_real();
	}
#if defined(PC) && !defined(_ia64_) && !defined(TARGETVXWORKS)
        makecpuid(job, ofp);
#endif

        fclose(ofp);
	exit(0);
	return 0;
}

static void do_real(void )
{
  char * varflags;
  char * funcflags;
  int nextvar;
  int gsize;
  char gvar[MAXVARNAME];
  char funcvar[MAXVARNAME];
  int counter;
  char keysizevar[MAXVARNAME];
  char varname[MAXVARNAME];
  char idxname[MAXVARNAME];
  char charptrname[MAXVARNAME];
  char switchname[MAXVARNAME];
  char level_ptr_name[MAXVARNAME];
  int i, j, got = 0, sign, sign_level;
  char *borrowstr = "\n#ifndef FLEXLM_DLL\n\
	{\n\
	  char *l_borrow_decrypt(void *, char *, int, int);\n\
		l_borrow_dptr = l_borrow_decrypt;\n\
	}\n#endif\n";

#define MAX_LINE_LEN 200 
#define MAX_RANDLINE_LEN 1000

	remove(VAR_TEMP_FILENAME);
	fpVar = fopen(VAR_TEMP_FILENAME, "wb+");
	if(fpVar == NULL)
	{
		perror("Unable to open required temp file.\n");
		exit(1);
	}
	unlink(VAR_TEMP_FILENAME);

	remove(FUNC_TEMP_FILENAME);
	fpFunc = fopen(FUNC_TEMP_FILENAME, "wb+");
	if(fpFunc == NULL)
	{
		perror("Unable to open required temp file.\n");
		exit(1);
	}
	unlink(FUNC_TEMP_FILENAME);

	CLEARF;
	CLEARV;

	srand(time(0));
	numwords = sizeof(words) / sizeof (char *);
	numvars = (MAX_DAEMON_NAME + 1) + (keysize * (sizeof(VENDORCODE))) + 1;
	numvars *= 30; /* to account for random lines */
	numvars += (L_BBLOCK_SIZE * 2); /* for borrow */
	randvarname(funcvar, "funcvar");
	randvarname(countervar, "countervar");
	randvarname(idxname, "idxname");
	randvarname(tempidxname, "tempidxname");
	randvarname(switchname, "switchname");
	randvarname(charptrname, "charptrname");
	randvarname(level_ptr_name, "level_ptr_name");
/* 
 *	Vars for l_svk (key5) replacement
 */
	randvarname (key5_fname, "key5_fname");
/*
 *	NOTE:	We have to be able to generate this ISVs VKEY5, *and*
 *		generate c-code that makes vkey5.  There's 3
 *		components to the new vkey5:  
 *			vdaemon name
 *			key5_uniqx
 *			key5_order
 */
	while (!key5_uniqx) /* unlikely we need more than one attempt */
	{
		key5_uniqx = ( our_rand(256)  +
		(our_rand(256)  << 8) +
		(our_rand(256)  << 16) +
		(our_rand(256)  << 24));
	}
	j = 0;
	while (got < 0xf)
	{
		i = our_rand(4);
		if (got & (1 << i))
			continue;
		key5_order[j++] = i;
		got |= 1 << i;
	}


/*
 *	Random lines -- at most one for each variable
 */
 	for (i = 0; i < 200; i += 2)
	{
		random_garbage();
	}
/* 
 *	set up varname for variable for number 1 & 2
 */
	for (i = 0; i < 256; i++)
	{
		do_constant(i, bytenames[i], byteassign[i]);
	}

	pvBuf = vBuf;
	pfBuf = fBuf;

/*
 *	vendorname 
 */
	do_string(vname, "buf", MAX_DAEMON_NAME, -1);
		
	for (counter = 0; counter < keysize; counter++)
	{
/*
 *		Call VKEY5 (which is original l_svk())
 *		to make seeds (data) raw
 */
		VKEY5(vname, &vendorkeys[counter]);
/*
 *		Now that they're raw, use key5() to
 *		XOR with the new key5
 */
 		key5(&vendorkeys[counter]);
		l_xorname(vname, &vendorkeys[counter]);
		do_ulong(vendorkeys[counter].data[0], "data[0]", counter);
		do_ulong(vendorkeys[counter].data[1], "data[1]", counter);
		do_ulong(vendorkeys[counter].keys[0], "keys[0]", counter);
		do_ulong(vendorkeys[counter].keys[1], "keys[1]", counter);
		do_ulong(vendorkeys[counter].keys[2], "keys[2]", counter);
		do_ulong(vendorkeys[counter].keys[3], "keys[3]", counter);
		do_ulong(vendorkeys[counter].crokeys[0], "crokeys[0]", counter);
		do_ulong(vendorkeys[counter].crokeys[1], "crokeys[1]", counter);
		do_ulong(pubkey_strength, "strength", counter);
		do_ulong(lm_sign_level, "sign_level", counter);
		for (sign = 0; sign < lm_sign_level;sign ++)
		{
		  LM_VENDORCODE_PUBKEYINFO *p;
		  char nam[30];
		  	p = &vendorkeys[counter].pubkeyinfo[sign];
			for (i = 0; i < LM_PUBKEYS;i ++)
			{
				sprintf(nam, "pubkeyinfo[%d].pubkeysize[%d]", 
								sign, i);
				do_ulong(p->pubkeysize[i] ?
					p->pubkeysize[i] : 
					public.pubkeyinfo[sign].pubkeysize[i],
						nam, counter);
			}
/*
 *			PUBKEYINFO -- public keys here 
 */
			for (i = 0; i < LM_PUBKEYS; i++)
			{
				for (j = 0; j < LM_MAXPUBKEYSIZ; j++)
				{
				  char nam[70];
					sprintf(nam, "pubkeyinfo[%d].pubkey[%d][%d]", sign, i, j);
					do_ulong(
						p->pubkey[i][j] ?
						p->pubkey[i][j] : 
					public.pubkeyinfo[sign].pubkey[i][j],
						nam, counter);
				}
			}
/*
 *			vendor_key->pubkeyinfo[].pubkey_fptr
 */
			CLEARF;
			sprintf(fBuf,
				"\tif (%s == %d) v->pubkeyinfo[%d].pubkey_fptr = %s;\n", 
				countervar, counter, sign,
				pubkey_strength >= LM_STRENGTH_PUBKEY ?
					"l_pubkey_verify" : "0");
			fwrite(fBuf, sizeof(fBuf), 1, fpFunc);
/*
 *			VENDORCODE.pubkeyinfo[].sign_level:
 *
 *			These are in reverse order.  The first entry is the
 *			highest sign level (lm_sign_level), the next is
 *			one lower and so on.  The lowest possible is 1 (SIGN=)
 */
			CLEARF;
			sprintf(fBuf, 
			"\tif (%s == %d) v->pubkeyinfo[%d].sign_level = %d;\n", 
				countervar, counter, sign, lm_sign_level - sign);
			fwrite(fBuf, sizeof(fBuf), 1, fpFunc);
		}
/*
 *		VENDORCODE.type
 */
		randvarname(varname, "varname");
		CLEARV;
		sprintf(vBuf, "static int %s = %d;\n", 
			varname, vendorkeys[counter].type);
		fwrite(vBuf, sizeof(vBuf), 1, fpVar);
		CLEARF;
		sprintf(fBuf,
			"\tif (%s == %d) v->type = (short)(%s & 0xffff) ;\n", 
			countervar, counter, varname);
		fwrite(fBuf, sizeof(fBuf), 1, fpFunc);
/*
 *		VENDORCODE.version
 */
		randvarname(varname, "var");
		CLEARV;
		sprintf(vBuf, "static int %s = %d;\n", 
			varname, vendorkeys[counter].flexlm_version);
		fwrite(vBuf, sizeof(vBuf), 1, fpVar);
		CLEARF;
		sprintf(fBuf, 
		"\tif (%s == %d) v->flexlm_version = (short)(%s & 0xffff) ;\n", 
			countervar, counter, varname);
		fwrite(fBuf, sizeof(fBuf), 1, fpFunc);
/*
 *		VENDORCODE.revision
 */
		randvarname(varname, "var");
		CLEARV;
		sprintf(vBuf, "static int %s = %d;\n", 
			varname, vendorkeys[counter].flexlm_revision);
		fwrite(vBuf, sizeof(vBuf), 1, fpVar);
		CLEARF;
		sprintf(fBuf, 
		"\tif (%s == %d) v->flexlm_revision = (short)(%s & 0xffff) ;\n", 
			countervar, counter, varname);
		fwrite(fBuf, sizeof(fBuf), 1, fpFunc);
/*
 *		VENDORCODE.flexlm_patch
 */
		randvarname(varname, "var");
		CLEARV;
		sprintf(vBuf, "static int %s = %d;\n", 
			varname, vendorkeys[counter].flexlm_patch[0]);
		fwrite(vBuf, sizeof(vBuf), 1, fpVar);
		CLEARF;
		sprintf(fBuf, 
		"\tif (%s == %d) v->flexlm_patch[0] = %s;\n", 
			countervar, counter, varname);
		fwrite(fBuf, sizeof(fBuf), 1, fpFunc);

/*
 *		VENDORCODE.behavior_ver
 */
		do_string(vendorkeys[counter].behavior_ver, 
				"v->behavior_ver", LM_MAX_BEH_VER, counter);
	}

	/*	flush both	*/
	fflush(fpVar);
	fflush(fpFunc);
/*
 *	dump declarations lines in random order
 */
	l_puts_rand(ofp, fpVar, numvars);
	fflush(ofp);
/*
 *	output unique l_svk()
 */
 	uniqcode();

	fflush(ofp);
/*
 *	function header
 */
	fprintf(ofp, "\
static\n\
int\n\
%s(buf, v, %s, %s, %s, %s)\n\
char *buf;\n\
VENDORCODE *v;\n\
unsigned int %s;\n\
unsigned char *%s;\n\
unsigned int %s;\n\
unsigned int *%s;\n\
{\n", 
	funcvar, switchname, charptrname, idxname, level_ptr_name,
		switchname, charptrname, idxname, level_ptr_name);
#ifndef RELEASE_VERSION
	fprintf(ofp, 
"\
/* \n\
 *	%s is a switch -- if 0, use to init vendorcode\n\
 *	then only buf and v and %s are used.\n\
 *	Otherwise, it's used to modify the handshake, \n\
 *	and then only %s, %s are used.\n\
 */\n", switchname, level_ptr_name, charptrname, idxname);
#endif
	fprintf(ofp, " static unsigned int %s;\n", countervar);
	fprintf(ofp, " unsigned int %s;\n", tempidxname);
	fprintf(ofp, " extern void %s();\n", L_SET_KEY5_FUNC_STR);
	fprintf(ofp, "\tif (%s) *%s = %d;\n", level_ptr_name, level_ptr_name, 
		lm_sign_level);

	if (L_INTERNAL_VAR(!readable_client, 1))
	{
	  char *p[256];
		for (i = 0; i < 256; i++)
			p[i] = byteassign[i];
		l_puts_rand1(ofp, 256, p);
	}
	do_handshake(charptrname, idxname, switchname);
	do_borrow(charptrname, idxname, switchname);

	fprintf(ofp, 
"	if (!buf)\n\
	{\n\
		%s = 0;\n\
		return 0;\n\
	}\n", 
	countervar);
	fprintf(ofp, "\tif (%s >= %d) return 0;\n", countervar, keysize);
	fprintf(ofp, "\t%s(%s);\n", L_SET_KEY5_FUNC_STR, key5_fname);
	fprintf(ofp, "\tmemset(v, 0, sizeof(VENDORCODE));\n");
	fflush(ofp);
/*
 *	dump func lines in rand order
 */
	l_puts_rand(ofp, fpFunc, numvars);

/*
 *	Borrow
 */
	if (l_borrow_ok) fprintf(ofp, borrowstr);

/* 	
 *	finish
 */
 	fprintf(ofp, "\t++%s;\n\treturn %d;\n}\nint (*%s)() = %s;\n", 
				countervar, keysize, L_NEW_JOB_STR, funcvar);

	/*	Detele temp files	*/
	if(fpVar)
	{
		fclose(fpVar);
		fpVar = NULL;
		remove(VAR_TEMP_FILENAME);
	}
	if(fpFunc)
	{
		fclose(fpFunc);
		fpFunc = NULL;
		remove(FUNC_TEMP_FILENAME);	
	}
}

char *vnames[] = {"data[0]", "data[1]", "keys[0]", "keys[1]", "keys[2]",
  	"keys[3]", "keys[4]", "crokeys[0]", "crokeys[1]"
		};
static
void
random_garbage()
{
  int i;
  int numout = 0;
  char gvar[MAXVARNAME];
  char j;
  int doarray;

	CLEARV;
	CLEARF;
	pvBuf = vBuf;
	pfBuf = fBuf;


	if (L_INTERNAL_VAR(readable_client, 1))
		return;
	randvarname(gvar, "gvar");
        i = our_rand(60);
        if (i>0)
        {
		doarray = 0;
		if (our_rand(2))
			doarray = 1;
		if (doarray)
		{
			sprintf(pvBuf, "static unsigned char %s[] = { %s\n\t", 
				gvar, DEVCOMMENT("/* Unused */"));
		}
		else
		{
			sprintf(pvBuf, "static unsigned char %s = %d; %s\n",
				gvar, our_rand(256), 
				DEVCOMMENT("/* random garbage */"));
		}
		pvBuf += strlen(pvBuf);
		if (doarray)
		{
			for (j = our_rand(4); j; j--)
			{
				sprintf(pfBuf, "\t%s[%d] = '%c'; %s\n", 
					gvar, our_rand(i), our_rand(26) + 'a',
					DEVCOMMENT("/*Unused*/"));
				pfBuf += strlen(pfBuf);
			}
		}
		else
		{
			sprintf(pfBuf, "\t%s = %d; %s\n", 
			gvar, our_rand(256), DEVCOMMENT("/* Unused */"));
			pfBuf += strlen(pfBuf);
		}
			
		if (doarray)
		{
			sprintf(pfBuf, 
			"\tif (%s == %d) v->%s += (%s[%d] << %d);%s\n", 
			countervar, keysize + our_rand(10), vnames[our_rand(6)],
				gvar, our_rand(i), 8 * our_rand(4),
				DEVCOMMENT("/* Unused */"));
		}
		else
		{
			sprintf(pfBuf, 
			"\tif (%s == %d) v->%s += (%s << %d);%s\n", 
			countervar, keysize + our_rand(10), vnames[our_rand(6)],
				gvar, 8 * our_rand(4),
				DEVCOMMENT("/* Unused */"));
		}
		pfBuf += strlen(pfBuf) + 1;
                while (doarray && i--)
                {
                        sprintf(pvBuf, "%3d", val());
			pvBuf += strlen(pvBuf);
                        numout++;
                        if (i > 0)
                        {
                                sprintf(pvBuf, ", ");
				pvBuf += strlen(pvBuf);
                                if ((numout % 10) == 0)
                                {
                                        sprintf(pvBuf, "\n\t");
					pvBuf += strlen(pvBuf);
                                        numout = 0;
				}
			}
                }
                if (doarray)
		{
			sprintf(pvBuf, "\t};\n");
		}
		pvBuf += strlen(pvBuf) + 1;
		pfBuf++;
        }
	if(vBuf[0] != '\0')
	{
		fwrite((void *)vBuf, sizeof(vBuf)/*sizeof(vBuf)*/, 1, fpVar);
		fflush(fpVar);
	}
	if(fBuf[0] != '\0')
	{
		fwrite((void *)fBuf, sizeof(fBuf)/*sizeof(fBuf)*/, 1, fpFunc);
		fflush(fpFunc);
	}
	
}

#define BIAS 20         /* Bias of 0's in percent/2 for BIAS == 0-100 */
#define BIASNUM  ( (256 * BIAS) / 100 )

static
unsigned 
int
val()
{
  int i;

        i = our_rand(256 + BIASNUM);
        i -= BIASNUM;
        if (i < 0)
		i = 0;
        return(i);
}

static
unsigned int
our_rand(max)
int max;
{
        return ((unsigned int) (rand() % max));
}

static
void
randvarname(buf, realname)
char *buf;
char *realname;
{
  static int R = 0; /* to make them unique */
  static char word[MAXVARNAME];

	if (L_INTERNAL_VAR(readable_client, 0))
	{
		sprintf(buf, "%s_%d", realname, R++);
		return;
	}

	R += our_rand(4) + 1;
	strcpy(word, words[our_rand(numwords)]);
	if (R % 2)
		sprintf(buf, "l_%s_%d", word, R);
	else
		sprintf(buf, "l_%d%s", R, word);
}

/*
 *	do_ulong -- generate code that initializes a
 *	an element of an unsigned long array
 *	
 */
static
void
do_ulong(unsigned long ul, /* value it needs to be init'd to */
	char *varname, 		/* name of variable */
	int counter) 		/* index into the array of varname */
{
  char b1[MAXVARNAME];
  char b2[MAXVARNAME];
  char b3[MAXVARNAME];
  char b4[MAXVARNAME];
  char *bnames[4];
  long longbits = 0;
  int shift;
  int i;

	randvarname(b1, "b1");
	randvarname(b2, "b2");
	randvarname(b3, "b3");
	randvarname(b4, "b4");
	bnames[0] = b1;
	bnames[1] = b2;
	bnames[2] = b3;
	bnames[3] = b4;
/*
 *	Break ul into 4 bytes.  Create 4 variables, one for
 *	each byte.  Assign these bytes one at a time.   
 *	These can be assigned in random order, so these
 *	lines are safe for shuffling in the output.
 */
	for (i = 0; i < 4; i++)
	{
		shift = i * 8;

		/* Add the variable decls to varbuf */

		CLEARV;
		sprintf(vBuf, "static unsigned int %s = %d;\n", 
			bnames[i], (ul & (0xff << shift)) >> shift );
		fwrite(vBuf, sizeof(char), sizeof(vBuf), fpVar);

		/* add the executable code to funcbuf */

		CLEARF;
		sprintf(fBuf, "\tif (%s == %d) v->%s += (%s << %d);\n", 
			countervar, counter, varname, bnames[i], shift);
		fwrite(fBuf, sizeof(char), sizeof(fBuf), fpFunc);

	}
}

static void
VKEY5(vendor_id, key)
char *vendor_id;
VENDORCODE *key;
{
  unsigned long keys[4];
  unsigned long signature;
#define SIGSIZE 4
  char sig[SIGSIZE];
  /*- unsigned long x = 0xa8f38730;                   v3.1 */
  /*- unsigned long x = 0x7648b98e;                   v7.0 */
  unsigned long x = 0x6f7330b8;                   /*- v8.x */
  int i = SIGSIZE-1;

/*-
 *      First, verify the key
 */
        l_key(vendor_id, &(key->keys[0]), keys, 4);


	sig[0] = sig[1] = sig[2] = sig[3] = '\0';

	while (*vendor_id)
	{
		sig[i] ^= *vendor_id++;
		i--;
		if (i < 0)
			i = SIGSIZE-1;
	}
	signature = (long)sig[0] |
		    ((long)sig[1] << 8) |
		    ((long)sig[2] << 16) |
		    ((long)sig[3] << 24);
	signature ^= x;
	signature ^= keys[1];
	signature ^= keys[2];
	signature &= 0xffffffff;
	if (signature == 0)
		signature = x;      /* 0 invalid */
	key->data[0] ^= signature;
	key->data[1] ^= signature;
}

/*
 *	Following are 2 functions, uniqcode() and key5()
 *	uniqcode writes C codes out to ofp that does (almost) exactly 
 *	what key5 does.
 */
static void uniqcode(void )
{
/*
 *	This prints out the source to the "vendor-key5" function.
 *	There's one added obfuscation:  
 *	We store a random number in the job.  The seeds are left xord
 *	with this random number.  
 */
  char buf[MAX_LINE_LEN * (SEEDS_XOR_NUM * 2)];
  char *cp = buf;
  char *cpp[SEEDS_XOR_NUM * 2];
  int i, j;
  int idx = *vendor_name % XOR_SEEDS_ARRAY_SIZ;
  int xor_arr[XOR_SEEDS_ARRAY_SIZ][4];

	XOR_SEEDS_INIT_ARRAY(xor_arr)

 	fprintf(ofp, 
"static\n\
void\n\
%s(job, vendor_id, key)\n\
char * job;\n\
char *vendor_id;\n\
VENDORCODE *key;\n\
{\n\
#define SIGSIZE 4\n\
  char sig[SIGSIZE];\n\
  unsigned long x = 0x%x;\n\
  int i = SIGSIZE-1;\n\
  int len = strlen(vendor_id);\n\
  long ret = 0;\n\
  struct s_tmp { int i; char *cp; unsigned char a[12]; } *t, t2;\n\
\n\
	sig[0] = sig[1] = sig[2] = sig[3] = 0;\n\
\n\
	if (job) t = (struct s_tmp *)job;\n\
	else t = &t2;\n\
	if (job)\n\
	{\n", key5_fname, key5_uniqx);

	for(i = 0; i < SEEDS_XOR_NUM; i++)
	{
	  unsigned char num;
		cpp[i] = cp;
		sprintf(cp, "\
		t->cp=(char *)(((long)t->cp) ^ (time(0) ^ ((0x%x << 16) + 0x%x)));\n\
		t->a[%d] = (time(0) & 0xff) ^ 0x%x;\n", 
		our_rand(0xff), our_rand(0xff), i, our_rand(0xff));
		cp += strlen(cp) + 1;
	}
/*
 *	print these in random order
 */
	l_puts_rand1(ofp, SEEDS_XOR_NUM, cpp);

 	fprintf(ofp, "\
	}\n\
	else\n\
	{\n\
		return;\n\
	}\n\
\n\
	for (i = 0; i < %d; i++)\n\
	{\n\
		if (sig[i%%SIGSIZE] != vendor_id[i%%len])\n\
			sig[i%%SIGSIZE] ^= vendor_id[i%%len];\n\
	}\n\
	key->data[0] ^= \n\
		(((((long)sig[0] << %d)| \n\
		    ((long)sig[1] << %d) |\n\
		    ((long)sig[2] << %d) |\n\
		    ((long)sig[3] << %d))\n\
		^ ((long)(t->a[%d]) << 0)\n\
		^ ((long)(t->a[%d]) << 8)\n\
		^ x\n\
		^ ((long)(t->a[%d]) << 16)\n\
		^ ((long)(t->a[%d]) << 24)\n\
		^ key->keys[1]\n\
		^ key->keys[0]) & 0xffffffff) ;\n\
	key->data[1] ^=\n\
		(((((long)sig[0] << %d)| \n\
		    ((long)sig[1] << %d) |\n\
		    ((long)sig[2] << %d) |\n\
		    ((long)sig[3] << %d))\n\
		^ ((long)(t->a[%d]) << 0)\n\
		^ ((long)(t->a[%d]) << 8)\n\
		^ x\n\
		^ ((long)(t->a[%d]) << 16)\n\
		^ ((long)(t->a[%d]) << 24)\n\
		^ key->keys[1]\n\
		^ key->keys[0]) & 0xffffffff);\n\
	t->cp -= %d;\n\
}\n", 
		MAX_DAEMON_NAME, 
		/* data[0] */
		key5_order[0], key5_order[1], key5_order[2], key5_order[3],
		xor_arr[idx][0],xor_arr[idx][1],xor_arr[idx][2],xor_arr[idx][3],

		/* data[1] */
		key5_order[0], key5_order[1], key5_order[2], key5_order[3],
		xor_arr[idx][0],xor_arr[idx][1],xor_arr[idx][2],xor_arr[idx][3],

		our_rand(10));
		
}

static
void
key5(k)
VENDORCODE *k;
{
  unsigned long *keys;
  unsigned long signature;
#define SIGSIZE 4
  char sig[SIGSIZE];
  int i = SIGSIZE-1;
  int len = strlen(vendor_name);

	sig[0] = sig[1] = sig[2] = sig[3] = 0;

	for (i = 0; i < MAX_DAEMON_NAME; i++)
	{
		if (sig[i%SIGSIZE] != vname[i%len])
			sig[i%SIGSIZE] ^= vname[i % len];
	}
	k->data[0] ^= 
		(((((long)sig[0] << key5_order[0])| 
		    ((long)sig[1] << key5_order[1]) |
		    ((long)sig[2] << key5_order[2]) |
		    ((long)sig[3] << key5_order[3]))
		^ key5_uniqx
		^ k->keys[1]
		^ k->keys[0]) & 0xffffffff);
	k->data[1] ^=
		(((((long)sig[0] << key5_order[0])| 
		    ((long)sig[1] << key5_order[1]) |
		    ((long)sig[2] << key5_order[2]) |
		    ((long)sig[3] << key5_order[3]))
		^ key5_uniqx
		^ k->keys[1]
		^ k->keys[0]) & 0xffffffff);
}

static
void
do_string(str, name, len, counter)
char *str, *name;
int len;
{
  char varname[MAXVARNAME];
  int i;



 	for (i = 0; i < len; i++)
	{
		pfBuf = fBuf;
		pvBuf = vBuf;
		CLEARV;
		CLEARF;
		randvarname(varname, "var");
		sprintf(pvBuf, "static char %s = %d;\n", varname, str[i]);
		pvBuf += strlen(pvBuf) + 1;
		sprintf(pfBuf, "\t");
		pfBuf += strlen(pfBuf);
		if (counter > -1)
		{
			sprintf(pfBuf, "if (%s == %d) ",
						countervar, counter);
			pfBuf += strlen(pfBuf);
		}
		sprintf(pfBuf, "%s[%d] = %s;\n", 
			name, i, varname);
		pfBuf += strlen(pfBuf) + 1;

		/*	Output each line	*/
		fwrite(vBuf, sizeof(vBuf), 1, fpVar);
		fwrite(fBuf, sizeof(fBuf), 1, fpFunc);
	}
	/*	P3264 -- null terminate string */

	CLEARV;
	CLEARF;
	pfBuf = fBuf;
	pvBuf = vBuf;
	randvarname(varname, "var");
	sprintf(pvBuf, "static char %s = %d;\n", varname, 0);
	pvBuf += strlen(pvBuf) + 1;
	sprintf(pfBuf, "\t");
	pfBuf += strlen(pfBuf);
	if (counter > -1)
	{
		sprintf(pfBuf, "if (%s == %d) ",
					countervar, counter);
		pfBuf += strlen(pfBuf);
	}
	sprintf(pfBuf, "%s[%d] = %s;\n", 
		name, len, varname);
	/*	Output line	*/
	fwrite(vBuf, sizeof(vBuf), 1, fpVar);
	fwrite(fBuf, sizeof(fBuf), 1, fpFunc);
}

errexit(str1, str2)
char * str1, *str2;
{
	fprintf(stderr, 
		"%s%s%s\nusage: lmnewgen vendorname [-o outfile1]\n	default output is lm_n.c\n", 
		str1, str2 ? ": " : "", str2 ? str2 : "");
	exit(1);

}

static void do_small_flag(void)
{
  int counter, i, j, sign;
  LM_VENDORCODE_PUBKEYINFO *p, *pub;
  char *str1 = "\
\n\
static\n\
int\n\
vc(buf, v, x, y, z, a)\n\
char *buf;\n\
VENDORCODE *v;\n\
int x;\n\
char *y;\n\
int z;\n\
int *a;\n\
{\n\
  static int c;\n\
\n\
	if (x) return 0;\n\
\n\
	if (!buf)\n\
	{\n\
		c = 0;\n\
		return 0;\n\
	}\n\
	if (c > %d) return 0;\n\
	memset(v, 0, sizeof(VENDORCODE));\n\
	strcpy(buf, \"%s\");\n";

  char *str2 = "\
	if (c == %d) v->keys[0] = 0x%x;\n\
	if (c == %d) v->keys[1] = 0x%x;\n\
	if (c == %d) v->keys[2] = 0x%x;\n\
	if (c == %d) v->keys[3] = 0x%x;\n\
	if (c == %d) v->crokeys[0] = 0x%x;\n\
	if (c == %d) v->crokeys[1] = 0x%x;\n\
	if (c == %d) v->sign_level = 0x%x;\n\
	if (c == %d) v->strength = 0x%x;\n\
	if (c == %d) v->data[0] = 0x%x;\n\
	if (c == %d) v->data[1] = 0x%x;\n";



  char *str3 = "\
	v->type = %d;\n\
	strcpy(v->behavior_ver, \"%s\");\n\
	v->flexlm_version = %d;\n\
	v->flexlm_revision = %d;\n\
	v->flexlm_patch[0] = %d;\n\
	c++;\n\
	return %d;\n\
}";
  char *borrowstr = "\n#ifndef FLEXLM_DLL\n\
	{\n\
	  char *l_borrow_decrypt(void *, char *, int, int);\n\
		l_borrow_dptr = l_borrow_decrypt;\n\
	}\n#endif\n";


	fprintf(ofp, str1, keysize, vendor_name);
	fprintf(ofp, "\tif (a) *a = %d;\n", lm_sign_level);
	for (counter = 0; counter < keysize; counter++)
	{
		fprintf(ofp, str2, 
			counter, vendorkeys[counter].keys[0],
			counter, vendorkeys[counter].keys[1],
			counter, vendorkeys[counter].keys[2],
			counter, vendorkeys[counter].keys[3],
			counter, vendorkeys[counter].crokeys[0],
			counter, vendorkeys[counter].crokeys[1],
			counter, lm_sign_level,
			counter, pubkey_strength,
			counter, vendorkeys[counter].data[0],
			counter, vendorkeys[counter].data[1]);
		fprintf(ofp, "\tif (c == %d)\n\t{\n", counter);
		for (sign = 0; sign < lm_sign_level; sign++)
		{
			p = &vendorkeys[counter].pubkeyinfo[sign];
			pub = &public.pubkeyinfo[sign];
			fprintf(ofp, 
"\t\tv->pubkeyinfo[%d].pubkeysize[0] = 0x%x;\n\
\t\tv->pubkeyinfo[%d].pubkeysize[1] = 0x%x;\n\
\t\tv->pubkeyinfo[%d].pubkeysize[2] = 0x%x;\n\
\t\tv->pubkeyinfo[%d].strength = 0x%x;\n\
\t\tv->pubkeyinfo[%d].sign_level = 0x%x;\n\
\t\tv->pubkeyinfo[%d].pubkey_fptr = %s;\n",
		sign, p->pubkeysize[0] ? p->pubkeysize[0] : pub->pubkeysize[0],
		sign, p->pubkeysize[1] ? p->pubkeysize[1] : pub->pubkeysize[1],
		sign, p->pubkeysize[2] ? p->pubkeysize[2] : pub->pubkeysize[2],
		sign, p->strength ? p->strength : pubkey_strength,
		sign, lm_sign_level,
		sign, pubkey_strength >= LM_STRENGTH_PUBKEY ?
                                "l_pubkey_verify" : "0");
				

			for (i = 0; i < LM_PUBKEYS; i++)
			{
				for (j = 0; j < LM_MAXPUBKEYSIZ; j++)
				{
					fprintf(ofp, 
			"\t\tv->pubkeyinfo[%d].pubkey[%d][%d] = 0x%x;\n", 
						sign, i, j,
					p->pubkey[i][j] ?
					p->pubkey[i][j] : 
					public.pubkeyinfo[sign].pubkey[i][j]);
				}
			}
		}
		fprintf(ofp, "\t}\n", counter);
	}
	if (l_borrow_ok)
	{
		fprintf(ofp, borrowstr);
	}
	fprintf(ofp, str3, VENDORCODE_6, 
		vendorkeys[0].behavior_ver, 
		vendorkeys[0].flexlm_version, 
		vendorkeys[0].flexlm_revision, 
		vendorkeys[0].flexlm_patch[0], 
		keysize);
 	fprintf(ofp, "\nint (*%s)() = vc;\n", 
				L_NEW_JOB_STR);
}

static void do_handshake(char *charptrname, char *idxname, char *switchname)
{
  char charname[MAXVARNAME];
  int i[4];
  char zeroname[MAXVARNAME];

	randvarname(charname, "charname");
	randvarname(zeroname, "zero");
	srand16((seed3 ^seed4) & 0xffff, (seed3 + seed4) & 0xffff,
		((seed3 ^ seed4) >> 16) & 0xffff, lmrands);
	rand16(lmrands, 1);
	rand16(lmrands, 1);
	rand16(lmrands, 1);
	i[0] = rand16(lmrands, 1);
	i[1] = rand16(lmrands, 1);
	i[2] = rand16(lmrands, 1);
	i[3] = rand16(lmrands, 1);
	fprintf(ofp, 
"	if (%s == %s) %s\n\
	{\n\
	  unsigned char %s = *%s;\n\
	  unsigned int %s = %s/%d; %s\n\
\n\
		if ((%s == %s) && ((%s ^ %d) & 0xff)) %s ^= %d;\n\
		if ((%s == (%s + 1)) && ((%s ^ %d) & 0xff)) %s ^= %d;\n\
		if ((%s == (%s + 3)) && ((%s ^ %d) & 0xff)) %s ^= %d;\n\
		if ((%s == (%s + 2)) && ((%s ^ %d) & 0xff)) %s ^= %d;\n\
		*%s = %s;\n\
		return 0;\n\
	}\n", switchname, bytenames[1],
	DEVCOMMENT("/* == 1 for handshake */"),
	charname, charptrname,
	zeroname, charname, rand16(lmrands, 1)%400 + 257, 
	DEVCOMMENT("/* The result of the divide is guaranteed to be zero */"),
	idxname, zeroname, charname, i[0], charname, i[0],
	idxname, zeroname, charname, i[1], charname, i[1],
	idxname, zeroname, charname, i[2], charname, i[2],
	idxname, zeroname, charname, i[3], charname, i[3],
	charptrname, charname);
}


/*
 * Static variables
 */

static char* program_name;
static char* variable_name_base = NULL;

/*
 * This is the character array that holds the cpuid function.
 */

#if defined(PC)  && !defined(TARGETVXWORKS)
extern unsigned char l_gcspimx[];

/*****************************************************************************
 *
 * Diagnostic tool: saves data to files.
 *
 ****************************************************************************/

static void
save_to_file( unsigned char *buff, int size, char *name )
{
	FILE *fp;
	int x, i;

	fp = fopen( name, "w" );
	if( NULL == fp )
		return;

	fprintf( fp, "DATA...\n    " );

	i = x = 0;
	while( i < size )
	{
		if( 10 <= x )
		{
			fprintf( fp, "\n    " );
			x = 0;
		}

		fprintf( fp, "%02x ", buff[i] );
		++i;
		++x;
	}

	fprintf( fp, "\n" );
	fclose( fp );
}



/*****************************************************************************
 *
 * Makes a copy of the function.  Note the first three bytes are its size.
 *
 ****************************************************************************/

static void
get_data( int *size_ptr, unsigned char **buff_ptr )
{
  unsigned char *rd_ptr;
  unsigned char *buff;
  int size;
  int i;

	rd_ptr = l_gcspimx;

	size = 0;
	for( i = 0; i < 3; i++ )
	{
		size <<= 8;
		size += (int) *rd_ptr++;
	}

	buff = calloc( 1, size + 5 );
	memcpy( buff, rd_ptr, size );

	*size_ptr = size;
	*buff_ptr = buff;
}

/*****************************************************************************
 *
 * Takes in the array and fills it with junk to make it randomly bigger.
 *
 ****************************************************************************/

static void
muddle_the_data( LM_HANDLE_PTR job, int *size_ptr, char **data, unsigned short *return_mask )
{
  unsigned char xor_buff[10];
  int xor_size;
  unsigned short mask;
  int pad_count;
  unsigned short a;
  int i;
  int x;
  int new_size;
  char *new_buff;
  char *wrPtr;
  char *rdPtr;
  int real_remaining;
  int muddled_size;
  unsigned short xor_sum;
  unsigned short next_val;
  unsigned short modifier;

	if( 2 != sizeof(unsigned short) )
	{
		fprintf( stderr, "Code is written for \"short\" being 16 bits"
				" and it's %d bits", 8 * sizeof(short) );
		exit( -1 );
	}

	/*
	 * Create a random 16 bit value.  Note that we're only
	 * going to use 15 bits of it so that we have an
	 * odd pattern.  Note also we can't have a mask that is
	 * all 1's.
	 */

	srand( (unsigned int) time( NULL ) );

	for(;;)
	{
		mask = rand();

		for( i = 0, pad_count = 0, a = 0x01; i < 15; i++, a <<= 1 )
		{
			if( mask & a )
				continue;
			++pad_count;
		}

		/*
		 * To work properly, there must be between 3 and
		 * 12 pad bytes.
		 */

		if( (3 <= pad_count) && (12 >= pad_count) )
			break;
	}

	/*
	 * Create 7 random mask values.
	 */

	xor_size = 7;
	for( i = 0; i < xor_size; i++ )
		xor_buff[i] = (unsigned char) rand();


	/*
	 * Allocate enough memory to hold the muddled data.
	 */

	new_size = 15 * ( ((*size_ptr)+(15-pad_count-1)) / (15-pad_count) );
	new_size += 20;	/* The xor_buff plus just-in-case padding */
	new_buff = calloc( 1, new_size );

	/*
	 * Using the 15 random bits as a pattern, write out either a
	 * random value, or a real one.
	 */

	real_remaining = *size_ptr;
	rdPtr = *data;

	wrPtr = new_buff;
	a = 0x01;
	i = 0;
	x = 0;

	muddled_size = 0;

	while( real_remaining )
	{
		/*
		 * Reset the mask if we've reached the
		 * end of it.
		 */

		if( x >= 15 )
		{
			x = 0;
			a = 0x01;
		}

		/*
		 * Write either one of the real values if the mask
		 * bit is set, or a random one if it's not set.
		 * Note that if it's a real byte we'll also mask
		 * it a little with an XOR.
		 */

		if( mask & a )
		{
			*wrPtr = *rdPtr++;
			*wrPtr ^=  xor_buff[i % xor_size];
			++wrPtr;
			--real_remaining;
		}
		else
			*wrPtr++ = (char) rand();

		++muddled_size;
		++i;
		++x;
		a <<= 1;
	}

	/*
	 * Finish out the mask pattern, then align it to
	 * be an even number of 16 bit groups.
	 */

	while( i < 15 )
	{
		*wrPtr++ = (char) rand();
		++muddled_size;
		++i;
	}

	i = 2 - (muddled_size % 2);
	while( (0 < i) && (2 > i) )
	{
		*wrPtr++ = (char) rand();
		++muddled_size;
		--i;
	}

	/*
	 * Sanity check the data sizes.
	 */

	if( muddled_size > new_size )
	{
		fprintf( stderr, "Bad math. %d>%d Buffer overrun", muddled_size, new_size );
		exit( -1 );
	}

	/*
	 * Perform a 16 bit XOR summation of the muddled data.  We're going
	 * to manipulate some of the pad values so that the XOR sum (one's
	 * compliment addition) equals the mask value.
	 */

	i = 0;
	xor_sum = 0;

	while( i < muddled_size )
	{
		for( next_val = 0, x = 0; x < 2; x++, i++ )
		{
			next_val <<= 8;
			next_val += (unsigned char) new_buff[i];
		}

		xor_sum ^= next_val;
	}

	modifier = xor_sum ^ mask;

	/*
	 * Find the correct place to add in our modifiers.
	 */

	for( i = 0, a = 0x01; i < 15; i++, a <<= 1 )
	{
		if( !(mask & a) )
			break;
	}

	/*
	 * Insert the low byte modifier.  This must go
	 * at an odd address.
	 */

	x = i;
	while( !(x & 0x01) )
		x += 15;

	new_buff[x] ^= (unsigned char) (modifier & 0x0ff);

	/*
	 * Find the next place to insert a modifier.
	 */

	for( ++i, a <<=1; i < 15; i++, a <<= 1 )
	{
		if( !(mask & a) )
			break;
	}

	/*
	 * Insert the high byte modifier.  This must go
	 * at an even address.
	 */

	x = i;
	while( x & 0x01 )
		x += 15;

	new_buff[x] ^= (unsigned char) ((modifier >> 8) & 0x0ff);

	/*
	 * Write out the xor mask values used at the tail end
	 * of the data.
	 */

	new_buff[muddled_size] = xor_size;
	for( i = 0; i < xor_size; i++ )
		new_buff[muddled_size+i+1] = xor_buff[i];

	/*
	 * Return our work.
	 * Send back the mask value so that it can be verified.
	 */

	*data = new_buff;
	*size_ptr = muddled_size;
	*return_mask = mask;
}

/*****************************************************************************
 *
 * Verify muddled data
 *
 ****************************************************************************/

static void
verify_muddled_data( LM_HANDLE *job, char *buff, int size, unsigned short mask )
{
  int i; 
  unsigned short xor_sum;
  unsigned short next_val;
  unsigned char *hold_buff;
  unsigned char *check_buff;
  int check_size;
  unsigned char *start_buff;
  int start_size;
  int xor_size;

	/*
	 * First make sure the checksum's agree.
	 */

	i = 0;
	xor_sum = 0;
	while( i < size )
	{
	  int x;

		for( x = 0, next_val = 0; x < 2; x++, i++ )
		{
			next_val <<= 8;
			next_val += (unsigned char) buff[i];
		}

		xor_sum ^= next_val;
	}

	if( xor_sum != mask )
	{
		fprintf( stderr, "Verify failed, 0x%x != 0x%x", xor_sum, mask );
		exit( -1 );
	}

	/*
	 * Next, unmuddle the data and make sure it matches what
	 * we started with.  Note we need to include the xor mask
	 * at the end that's not part of the input size value.  (It's
	 * hidden that way.)
	 */

	xor_size = (int) buff[size];


	hold_buff = calloc( 1, size + xor_size + 10 );
	memcpy( &hold_buff[3], buff, size + xor_size + 1 );
	hold_buff[0] = ((size >> 16) & 0xff);
	hold_buff[1] = ((size >>  8) & 0xff);
	hold_buff[2] = ((size >>  0) & 0xff);
	check_buff = hold_buff;

	l_demuddle( job, &check_buff, &check_size );
	get_data( &start_size, &start_buff );
	if( memcmp( check_buff, start_buff, start_size ) )
	{
		save_to_file( check_buff, check_size, "_out.txt" );
		save_to_file( start_buff, start_size, "_in.txt" );
		fprintf( stderr, "Verify failed, Input (_in.txt) != Output (_out.txt) \n" );
		exit( -1 );
	}

	free( hold_buff );
	lc_free_mem( job, check_buff );
	free( start_buff );
}

/*****************************************************************************
 *
 * Output's the data.
 *
 ****************************************************************************/

static void
output_muddled_data( unsigned char *buff, int size )
{
  int i;
  int x;
  int xor_size;
  int per_line;

	/*
	 * Ouput the size as the first three bytes; big-endien.
	 */

	fprintf( ofp, "unsigned char l_gcspim[] = {\n\
0x%02x,0x%02x,0x%02x,",
		(unsigned char) ((size >> 16) & 0xff),
		(unsigned char) ((size >>  8) & 0xff),
		(unsigned char) ((size >>  0) & 0xff) );

	for( i = 0, per_line = 3; i < size; i++, per_line++ )
	{
		if( 10 < per_line )
		{
			fprintf( ofp, "\n    " );
			per_line = 0;
		}

		fprintf( ofp, "0x%02x,", buff[i] );
	}

	/*
	 * Output the xor mask at the end.
	 */

	xor_size = (int) buff[i];
	for( x = 0; x <= xor_size; x++, per_line++ )
	{
		if( 10 < per_line )
		{
			fprintf( ofp, "\n    " );
			per_line = 0;
		}

		fprintf( ofp, "0x%02x,", buff[i+x] );
	}

	fprintf( ofp, "0x00\n};\n\n" );
}


static
void
makecpuid( LM_HANDLE *job, FILE *ofp)
{
  unsigned short mask;
  int size;
  unsigned char *buff;
  unsigned char *original_data;


	/*process_args( argc, argv );*/

	get_data( &size, &original_data );
	buff = original_data;
	muddle_the_data( job, &size, &buff, &mask );

	/*
	 * For bug catching reasons, we'll go through
	 * all the code to unmuddle the routine now to
	 * make sure that it works.
	 */

	verify_muddled_data( job, buff, size, mask );

	/*
	 * Output the data now.
	 */

	output_muddled_data( buff, size );

	/*
	 * Free dynamic memory.
	 */

	free( original_data );
	free( buff );

}
				
	
#endif /* PC */

static
void
do_constant(int val, char *name, char *namestr)
{
  char v1[MAXVARNAME];
  char v2[MAXVARNAME];
  unsigned int i;

	i = (rand() & 0xffff) + 1; /* add 1 to avoid div by zero */


	if (L_INTERNAL_VAR(readable_client, 0))
	{
		sprintf(name, "%d", val);
		return;
	}
	randvarname(name, "");
	randvarname(v1, "");
	randvarname(v2, "");
	CLEARV;
	sprintf(vBuf, "static unsigned int %s = %d;\t%s\n", v1, i * val,
		DEVCOMMENT("/*constant numerator*/"));
	fwrite(vBuf, sizeof(vBuf), 1, fpVar);

	CLEARV;
	sprintf(vBuf, "static unsigned int %s = %d;\t%s\n", v2, i,
		DEVCOMMENT("/*constant denominator*/"));
	fwrite(vBuf, sizeof(vBuf), 1, fpVar);

	CLEARV;
	sprintf(vBuf, "static unsigned int %s; \t/*%s %d */\n", name,
		DEVCOMMENT("constant variable:"),
#ifdef RELEASE_VERSION
		our_rand(20)
#else
		val
#endif
		);
	fwrite(vBuf, sizeof(vBuf), 1, fpVar);

	if (namestr)
		sprintf(namestr, "\t%s = %s/%s;\t/* %d */\n", name, v1, v2,
#ifdef RELEASE_VERSION
				our_rand(10)
#else
				val
#endif
			);
}

/*
 *	We need to return 2 unique numbers
 *	The plan is 
 *		 1) -- take seed3 and seed4 as seeds to srand16().
 *		 2) return the result to the caller 
 *	The first is returned as 2 different shorts.  
 *	This is used as seeds in the encryption that happens between
 *	the server and client.  This encryption uses static code,
 *	but seeds that are in lm_new.o
 *	The second unique number will be different everytime 
 *	that lmnewgen is run.  seeds3/4 and the time are 
 *	used as seeds to srand16().  This 2nd number is purely
 *	an identifier for lm_new.o, and is used in the
 *	borrow registry entry.  The combination of feature name
 *	and lm_new ID number (this 2nd number) is used for
 *	getting a license from the registry.
 */
#define L_SUB_SIZE 8
int sub[L_BBLOCK_SIZE][L_SUB_SIZE];
int arith[L_BBLOCK_SIZE];
int bitshift[L_BBLOCK_SIZE][8];
int which[L_BBLOCK_SIZE];
static 
void
do_borrow( char *charptrname, char *lenname, char *switchname)
{

  int i;
  int ret1;
  int ret2;
  int ret3;
  char retname[MAXVARNAME];
  char multname[MAXVARNAME];
  int mult1;
  int mult2;
  int mult3;
  long t = (long)time(0);

/*
 *	If we're not doing borrowing, flag this by returning 0 when the
 *	switch arg is 2, which is normally used to return a borrow value
 *	which can never be zero.
 */
	if (!l_borrow_ok)
	{
		fprintf(ofp, "\
	if (%s == %s) return %s; %s\n",
		switchname, bytenames[2], bytenames[0],
		DEVCOMMENT("/* No borrowing allowed */"));
		return;
	}
	if (borrow_fixed)  /* lm_new.c unique per ISV, but not per exe */
	{
		t = vendor_name[0] << 24 ^
			vendor_name[1] << 16 ^
			vendor_name[2] << 8 ^
			vendor_name[3];
	}

	srand16((seed3 +seed4) & 0xffff, (seed3 ^ seed4) & 0xffff,
		((seed3 + seed4) >> 16) & 0xffff, borrow_seeds);
	srand16(((seed3 + seed4) ^ t) & 0xffff, t >> 16, t >> 4 & 0xffff, 
							borrow_session_seeds);
	rand16_2(borrow_seeds);
	rand16_2(borrow_session_seeds);
	ret1 = (rand16_2(borrow_seeds) & 0xffff);
	ret1 >>= 1; /* make sure it's not negative;*/
	ret1 /= 16; /* make sure can mult by 16 ;*/
	ret2 = (rand16_2(borrow_seeds) & 0xffff);
	ret2 >>= 1; /* make sure it's not negative;*/
	ret2 /= 16;/* make sure can mult by 16 ;*/
	ret3 = (rand16_2(borrow_session_seeds) & 0xffff);
	ret3 ^= (rand16_2(borrow_session_seeds) << 16); 
	ret3 >>= 1; /* make sure it's not negative;*/
	ret3 /= 16;/* make sure can mult by 16 ;*/
	mult1 = our_rand(10) + 2;
	mult2 = our_rand(10) + 2;
	mult3 = our_rand(10) + 2;
	randvarname(retname, "ret");
	randvarname(multname, "mult");
	rand_arr(reorder_arr, L_BBLOCK_SIZE);
	fprintf(ofp, 
"	if (%s == %s) %s\n\
	{\n\
%s\n\
	  unsigned int %s = 0x%x; %s\n\
	  unsigned int %s = 0x%x;\n\
\n\
		return %s/%s; %s\n\
	}\n", switchname, bytenames[2], 
	DEVCOMMENT("/* == 2 */"),
	DEVCOMMENT("\
/*\n\
 *		This returns a unique number for borrowing security\n\
 */"),

	multname, mult1, DEVCOMMENT("/*multiplier*/"),
	retname, mult1 * ret1, retname, multname, 
	DEVCOMMENT("/* div by multipler */"));

	fprintf(ofp, 
"	if (%s == %s) %s\n\
	{\n\
%s\n\
	  unsigned int %s = 0x%x; %s\n\
	  unsigned int %s = 0x%x;\n\
\n\
		return %s/%s; %s\n\
	}\n", switchname, bytenames[3], 
	DEVCOMMENT("/* == 3 */"),
	DEVCOMMENT("\
/*\n\
 *		This returns a unique number for borrowing security\n\
 */"),

	multname, mult2, DEVCOMMENT("/*multiplier*/"),
	retname, mult2 * ret2, retname, multname, 
	DEVCOMMENT("/* div by multipler */"));

	fprintf(ofp, 
"	if (%s == %s) %s\n\
	{\n\
%s\n\
	  unsigned int %s = 0x%x; %s\n\
	  unsigned int %s = 0x%x;\n\
\n\
		return %s/%s; %s\n\
	}\n", switchname, bytenames[4], 
	DEVCOMMENT("/* == 4 */"),
	DEVCOMMENT("\
/*\n\
 *		Borrowing: a unique ID for this file\n\
 */"),

	multname, mult3, DEVCOMMENT("/*multiplier*/"),
	retname, mult3 * ret3, retname, multname, 
	DEVCOMMENT("/* div by multipler */"));

/*
 *	Initialize session values
 */
	rand_arr(arith, L_BBLOCK_SIZE);
	for (i = 0; i < L_BBLOCK_SIZE; i++)
	{
		which[i] = rand16_2(borrow_session_seeds) % 2;
		rand_arr(bitshift[i], 8);
		rand_arr(sub[i], L_SUB_SIZE);
	}
	
	{
		/* Setup #define for the number 32 */
			
	  int m = rand16_2(borrow_session_seeds) % 256 ;
		m += 1;
		randvarname(define32, "definefor32");
		fprintf(ofp, "#define %s (%d/%d) %s\n",
			define32, m * 32, m,
			DEVCOMMENT("/* define for 32 */"));
	}
			

		 

	borrow_cryptbegin(charptrname, lenname, switchname, 0, 0);
	borrow_cryptbegin(charptrname, lenname, switchname, 1, 0);
	borrow_cryptbegin(charptrname, lenname, switchname, 0, 1);
	borrow_cryptbegin(charptrname, lenname, switchname, 1, 1);

}

static 
void
borrow_cryptbegin( char *charptrname, char *lenname, char *switchname, 
	int decrypt_flag, 
	int passnum) /* passnum indicates which series of encryption pass */
{

  int i;

	if (!*cryptlabel)
		strcpy(cryptlabel, "label");
	else
		cryptlabel[0]++;

	cryptnum++;

	fprintf(ofp, "\
	if (%s == %s)\t/*%d*/\n\
		goto %s%s; %s\n\
	goto %saroundthis;\n\
%s%s: \n\
\n\
	return %s; %s\n\
%saroundthis:\n",
		switchname, 
		bytenames[cryptnum], 
		L_INTERNAL_VAR(cryptnum, our_rand(30)),
		cryptlabel, bytenames[0], 
		DEVCOMMENT("/* goto xabelxxx, this is the cryptor */"),
		cryptlabel,
		cryptlabel, bytenames[L_BBLOCK_SIZE], 
		bytenames[our_rand( 20)],
		DEVCOMMENT("/* return garbage, exit from cryptor */"),
		cryptlabel);
	for (i = 0; i < ((passnum == 0) ? L_BBLOCK_SIZE : 1); i++)
	{
		CLEARF;
		sprintf(fBuf, "\
	goto _%s%s; %s\n\
%s%s: /* %d */\n\
	for (%s = %s; %s < %s; %s += %s)\n\
	{\n\
%s\n\
	}\n\
	goto %s%s; /* %d */\n\
_%s%s: %s\n",
			cryptlabel, bytenames[i], DEVCOMMENT("/* skip around cryptor */"),
			cryptlabel, bytenames[i],  L_INTERNAL_VAR(i, our_rand(10)),
			/* for line: */
			tempidxname, bytenames[i], tempidxname, lenname,
			tempidxname, 
			bytenames[L_BBLOCK_SIZE],
			cryptcode(charptrname, tempidxname, lenname, i, 
				decrypt_flag, passnum),
			cryptlabel, 
			passnum == 0 ? bytenames[i+1]: bytenames[L_BBLOCK_SIZE],
			L_INTERNAL_VAR(i + 1, our_rand(10)),
			cryptlabel, bytenames[i],
			DEVCOMMENT("/* skip around encryptor */"));
		fwrite(fBuf, sizeof(fBuf), 1, fpFunc);
	}
}
/*
 *	Init an array of ints of 'size' with random numbers
 *	between 1 and 'size'
 */
static
void
rand_arr(int *ret, int size)
{
  int i;
  int *a, r, j;
	a = (int *)malloc(sizeof(int) * size);
	memset(a, 0, sizeof(int) * size);
	for (i = 0; i < size; i++)
		a[i] = i;
	for (i = size - 1; i  >= 0; i--)
	{

		if (i) r =  rand16(borrow_session_seeds, 1) % (i + 1);
		else r = 0;
		ret[i] = a[r];
		for (j = r; j < i; j++)
			a[j] = a[j + 1];
	}
}
/*
 *	cryptcode -- this provides the borrowing encrypt/decrypt code
 *	that is client-side only.
 *	
 *	This gets called L_BBLOCK_SIZE times.
 *	The generated code processes every character that is
 *	L_BBLOCK_SIZE (32) apart the same way.
 *	So, msg[0] and msg[32] get processed the same way.
 *
 *	There are several different methods: 
 *		arithmetic, and substitution
 *	The method that's used depends on the 'which' array.
 *	which has L_BBLOCK_SIZE--32 different values, and each one
 *	indicates which method is used.
 *
 *	arith also has L_BBLOCK_SIZE--32 random values.
 *	The number is simply added or subtracted during encryption,
 *	with the opposite sign during decryption.
 *	So, if which[0] indicates arithmethic, and if arith[0] is
 *	187, then 
 *	encrypt: msg[0] += 187, msg[32] += 187, msg[64] +=....
 *	decrypt: msg[0] -= 187, msg[32] -= 187, msg[64] -=....
 *	Since these are unsigned chars, they "rollover" like clock arithmetic
 *	when they go past 0 or 255.
 *
 *	We substitute one number for another, within a 
 *	small range:  L_SUB_SIZE, which is 8.
 *	The substition numbers are in the 'sub' array.
 *	The sub is a 2-dimensional array.
 *	There's 8 numbers between 0-7 once for each 
 *	L_BBLOCK_SIZE.
 *	Example:  	
 *		msg[0] is 43
 *		sub array is 7, 5, 3, 2, 6, 0, 4, 1 for offset 0
 *		43 % 8 = 3
 *		sub[3] = 2, which is the substitution number
 *		43/8 = 40 + 2 = 42, the new number
 *		To reverse it:
 *		43%8 = 2
 *		The inverse substution for 2 is 3
 *		43/8 = 40 + 3 = 43.
 */
char *
cryptcode(char *charptrname, char *tempidxname, char *lenname,
	int i, int decryptflag, int passnum)
{
  static char buf[BUF_SIZE];
  char sign;
  int s;
  char *cp = buf;
  int arr[L_SUB_SIZE];
  int j, k;
  int in, out;
  char c[MAXVARNAME + 1];
  char bufvar[MAXVARNAME + 1];
  char checkvar[MAXVARNAME + 1];
  char ivar[MAXVARNAME + 1];
	

	if (passnum == 0)
	{
	switch (which[i])
	{
	case 0:	 /* arith */
		if (arith[i]%2) sign = '-';
		else sign = '+';
		if (decryptflag) /* reverse sign */
		{
			if (sign == '-') sign = '+';
			else sign = '-';
				
		}
		sprintf(buf, "\
		%s[%s] %c= %s;\t%s\n",
			charptrname, tempidxname,  sign, bytenames[arith[i]],
			DEVCOMMENT("/* arithmetic operation */"));
		break;
	case 1:	 /* substitution */

		rand_arr(arr, L_SUB_SIZE);
		randvarname(c, "c"); /* char variable */

		cp = buf;
		sprintf(cp, "\
%s\n\
	  unsigned char %s = %s[%s];\n", DEVCOMMENT("\
/*\n\
 *		Substitution\n\
 */"), 
			c, charptrname, tempidxname);
		cp += strlen(cp);
		for (j = 0; j < L_SUB_SIZE; j++)
		{
			k = arr[j];
			if (decryptflag)
			{
				in = k;
				out = sub[i][k];
			}
			else
			{
				out = k;
				in = sub[i][k];
			}
			sprintf(cp, "\n\
		if ((%s %% %s) == %s) /* %d */\n\
			%s[%s] = ((%s/%s) * %s) + %s; /*sub %d*/\n",
				c, bytenames[L_SUB_SIZE], bytenames[in], 
				L_INTERNAL_VAR(in, our_rand(10)),
				charptrname, tempidxname, 
				c, bytenames[L_SUB_SIZE], 
				bytenames[L_SUB_SIZE], bytenames[out],
				L_INTERNAL_VAR(out, our_rand(10)));
			cp += strlen(cp);
		}
		sprintf(cp, "\n");
		break;
	}
	return buf;
	}
/*
 *	2nd pass:  reorder bytes
 */
	randvarname(bufvar, "buf");
	randvarname(checkvar, "check");
	randvarname(ivar, "k");

	cp = buf;
	sprintf(cp, "\
	  char %s[%s];\n\
	  unsigned int %s = %s + %s;\n\
	  unsigned int %s;\n\
\n\
		if (%s >= %s)\n\
			return %s; \n\
		memcpy(%s, &%s[%s], %s);\n\
		for (%s = %s; %s < %s; %s += %s)\n\
		{\n",
		bufvar, define32, 				/* line 1*/
		checkvar, tempidxname, bytenames[L_BBLOCK_SIZE],/* line 2 */
		ivar,						/* line 3 */
		checkvar, lenname,				/* line 4 */
		bytenames[our_rand(40)],			/* line 5 */
		bufvar, charptrname, tempidxname,
			bytenames[L_BBLOCK_SIZE],		/* line 6 */
		ivar, bytenames[0], ivar, bytenames[L_BBLOCK_SIZE],
			ivar, bytenames[1]);			/* line 7 */
	cp += strlen(cp);
	for (i = 0; i < L_BBLOCK_SIZE; i++)
	{
		if (decryptflag)
		{
			in = i; out = reorder_arr[i];
		}
		else
		{
			out = i; in = reorder_arr[i];
		}
		sprintf(cp, "\
			if (%s == %s) /*%d*/\n\
				%s[%s + %s] = %s[%s]; /* swap %d %d*/\n",
			ivar, bytenames[in], 
					L_INTERNAL_VAR(in, our_rand(32)),
			charptrname, bytenames[in], tempidxname,
				bufvar,bytenames[out],
			L_INTERNAL_VAR(in, our_rand(320)),
			L_INTERNAL_VAR(out, our_rand(32)));
		cp += strlen(cp);
	}
	sprintf(cp, "\
		}\n");
	return buf;

}

static
int
set_lm_case(void)
{
	if ((pubkey_strength >= LM_STRENGTH_113BIT) && !seed3 && seed1) 
	{
		fprintf(stdout, "Upgrading to CRO from v7.0 or earlier\n");
		return 1; /* case 1 */
	}
	if ((pubkey_strength == LM_STRENGTH_LICENSE_KEY) && !seed3 && seed1)
	{
		fprintf(stdout, "Upgrading, using license-key\n");
		return 2; /* case 2 */
	}
/*
 *	We don't support case 3, and unfortunately we have no way of
 *	detecting it either
 */
	if ((pubkey_strength == LM_STRENGTH_DEFAULT) && seed3 && 
		lm_sign_level == 1)
	{
		fprintf(stdout, "Upgrading from v7.2, using SIGN=, non-CRO\n");
		return 4; /* case 4 */
	}
	if ((pubkey_strength >= LM_STRENGTH_113BIT) && seed3)
	{
		if (lm_sign_level == 2)
		{
			fprintf(stdout, "Upgrading from v7.2 CRO, using SIGN2= for more security\n");
			return 5; /* case 5: migrating from old CRO */
		}
		if (lm_sign_level == 1)
		{
			fprintf(stdout, "Upgrading from v7.2 license-key to CRO\n");
			return 9; /* case 9: migrating from license-key to 
				     CRO, but didn't use CRO in v7.2*/
		}
		fprintf(stderr, 
		"ERROR:  Inconsistent lm_code.h file, unknown state \n\
		Probably ENCRYPTION_SEEDs or LM_STRENGTH set incorrectly\n");
		exit(1);
		
	}
/*
 *	We don't support case 6, and unfortunately we have no way of
 *	detecting it either.  But it's an error if someone's trying to do this
 */
	if ((pubkey_strength >= LM_STRENGTH_113BIT) && !seed1)
	{
		fprintf(stdout, "v8.1+ FLEXlm, using CRO\n");
		return 7; /* case 7 */
	}
	if ((pubkey_strength == LM_STRENGTH_DEFAULT) && !seed1)
	{
		fprintf(stdout, "v8.1+ FLEXlm, non-CRO\n");
		return 8; /* case 8 */
	}
	if ((pubkey_strength == LM_STRENGTH_LICENSE_KEY) && seed3)
	{
		fprintf(stdout, "Upgrading from v7.2 FLEXlm license-key\n");
		return 10; /* case 10 */
	}

	fprintf(stderr, 
	"ERROR:  Inconsistent lm_code.h file, unknown state \n\
	Probably ENCRYPTION_SEEDs or LM_STRENGTH set incorrectly\n");
	exit(1);

}

/**********************************************************************
	V8_1_COMMENT
Migration issues:

	We have the following migration paths:

	From			To
				v8.1 CRO	non-CRO
				--------	-------
	pre-v7.2 license-key	1		2 (no change)
	pre-v8.1 non-cro sign=	3		4 (no change)
	v7.2 CRO		5		6
	New			7		8
	v7.2 license-key	9		10

	Notes:
	Case 1:		license-key, SIGN= no SEED3/4.  use absence of seeds
			3 and 4 as signal that this is case 1.
	Case 2:		No change.  LM_STRENGTH is LM_STRENGTH_LICENSE_KEY
			LM_SIGN_LEVEL is 0
	Case 3:		We probably wont handle these now.  These are 
			companies that had the opportunity to buy CRO when
			they first purchased, and chose not to.  We actually
			didnt have a migration path for these in v7.2 or
			v8.0 either.
	Case 4:		No Change.  LM_STRENGTH is LM_STRENGTH_DEFAULT
			LM_SIGN_LEVEL is 1
	Case 5:		Migration:  SIGN and SIGN2.  Signal is that there
			are seeds 1-4 and LM_SIGN_LEVEL is 2.
	Case 6:		Not possible.  Cant go from CRO to non-CRO.
	Case 7:		New CRO customer.  LM_SIGN_LEVEL is 1.  
			Signal is no ENCRYPTION_SEEDS
	case 8:		LM_STRENGTH_DEFAULT.  LM_SIGN_LEVEL is 1.
			Signal is no ENCRYPTION_SEEDS
	case 9:		Unsupported.
	case 10:	No change.  LM_STRENGTH is LM_STRENGTH_LICENSE_KEY.
 *********************************************************************/ 
