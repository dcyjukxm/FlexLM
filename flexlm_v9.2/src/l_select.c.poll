/******************************************************************************

	    COPYRIGHT (c) 1996 by Globetrotter Software Inc.
	This software has been provided pursuant to a License Agreement
	containing restrictions on its use.  This software contains
	valuable trade secrets and proprietary information of 
	Globetrotter Software Inc and is protected by law.  It may 
	not be copied or distributed in any form or medium, disclosed 
	to third parties, reverse engineered or used in any manner not 
	provided for in said License Agreement except with the prior 
	written authorization from Globetrotter Software Inc.

 *****************************************************************************/
/*	
 *	Module:	%M% v%R%.%L%.%B%.%S%
 *
 *	Function: l_select()
 *
 *	Description:  Wraper around select
 *
 *	Parameters: same args as select
 *
 *	Return: 	same as select
 *
 *	D. Birns
 *	8/15/96
 *
 *	Last changed:  %G%
 *
 */
#include "lmachdep.h"
#include "lmclient.h"
#include "l_prot.h"
#if defined ( PC16) | defined (NLM)
struct timeval { long tv_sec; long tv_usec; } ;
typedef int * fd_set;
int API_ENTRY select ( int nfds, fd_set FAR *, fd_set FAR *, fd_set FAR *,
			const struct timeval FAR * );
#endif /* PC16 */

#ifdef SELECT_FD_SET
#define FD_SET_T fd_set
#else
#define FD_SET_T int
#endif /* SELECT_FD_SET */

#ifdef UNIX
#include <poll.h>
#include <time.h>
#include <sys/time.h>
static int poll_select lm_args(( int, FD_SET_T *, FD_SET_T *, FD_SET_T *, LM_TIMEVAL_PTR ));

static long use_select = -1;
#endif /* UNIX */

#ifdef WINNT
int PASCAL FAR  l__select (int nfds, int * readfds, int * writefds,
		int * except_fds, const struct timeval FAR * timeout);
#endif /* WINNT */

#ifdef OS2
/*
 * We need to do this because we don't want to include
 * pcsock.h in this file.
 */

struct timeval { long tv_sec; long tv_usec; } ;
typedef int * fd_set;
int API_ENTRY l__select( int nfds, fd_set*, fd_set*, fd_set*,
			const struct timeval* );
#define select(a,b,c,d,e) l__select(a,b,c,d,e)
#endif /* OS2 */

int
l_select(nfds, readfds, writefds, exceptfds, timeout)
int nfds;
int *readfds;
int *writefds;
int *exceptfds;
LM_TIMEVAL_PTR timeout;
{

#if defined( WINNT) || defined (OS2)
        if (!nfds && !readfds && !writefds && !exceptfds)
        {
                Sleep( (timeout->tv_usec/1000) + (timeout->tv_sec*1000) );
        	return 0;
	}
#endif

#ifdef PC16
        if (!nfds && !readfds && !writefds && !exceptfds)
        {
          DWORD end_time = GetTickCount()+(DWORD)(timeout->tv_sec*1000)+
			(DWORD) timeout->tv_usec;

		while( GetTickCount() < end_time )
			Yield();

		return 0;

        }
#endif

#if defined( NLM) || defined (WINNT) /* for Softimage */
	return l__select(nfds,
#else
	if (use_select == -1)
	{
#ifdef RELEASE_VERSION
		use_select = (long)!getenv("FLEXLM_USE_POLL");
#else
		use_select = (long)getenv("FLEXLM_USE_SELECT");
#endif /* RELEASE_VERSION */
	}
	if (use_select)
	{
		return select(nfds,
			(FD_SET_T *)readfds,
			(FD_SET_T *)writefds,
			(FD_SET_T *)exceptfds,
			timeout);
	}
	else
	{
		return poll_select(nfds,
			(FD_SET_T *)readfds,
			(FD_SET_T *)writefds,
			(FD_SET_T *)exceptfds,
			timeout);
	}
#endif /* PC */
}
#ifdef UNIX
static
int
poll_select(nfds, readfds, writefds, exceptfds, timeout)
int nfds;
FD_SET_T *readfds;
FD_SET_T *writefds;
FD_SET_T *exceptfds;
LM_TIMEVAL_PTR timeout;
{

#define MAX_LM_FDS 6000
#define FD_SET_SIZE sizeof(FD_SET_T)
#if 1
  struct pollfd filedes[MAX_LM_FDS], *p;
  int i, j;
  nfds_t pfd = 0;
  FD_SET_T *fds = 0;
  int mask;
  int ret;
  int ms;
	memset(filedes, 0, sizeof(struct pollfd) * nfds);
	if (readfds) 
	{
		mask = POLLRDNORM;
		fds = readfds;
	}
	else 
	{
		fds = writefds;
		mask = POLLWRNORM;
	}
	for(i=0;i<nfds;)
	{
		if (!((int *)fds)[i/FD_SET_SIZE])
		{
			i+=FD_SET_SIZE;
			continue;
		}
		for (j = i, i += FD_SET_SIZE; j < i; j++)
		{
			if (FD_ISSET(j, fds))
			{
				filedes[pfd].fd = j;
				filedes[pfd].events = mask;
				pfd++;
			}
		}
	}
	if (timeout)
		ms = (timeout->tv_usec/1000) + (timeout->tv_sec*1000);
	else ms = -1;
	if (fds) FD_ZERO(fds);
	if ((ret =  poll(filedes, pfd, ms)) > 0)
	{
		for (i=0;i < pfd; i++)
		{
			if (filedes[i].revents) 
			{
				FD_SET(filedes[i].fd, fds);
			}
		}
	}
	return ret;
#else
  long *in, *out, *ex;
  u_long b;
  int n, m, j;
  struct pollfd filedes[MAX_LM_FDS], *p;
  long ms;

	in = (long *)readfds->fds_bits;
        out = (long *)writefds->fds_bits;
        ex = (long *)exceptfds->fds_bits;
	p = filedes;
        for (n = 0; n < nfds; n += NFDBITS) {
                b = (u_long)(*in | *out | *ex);
                for (j = 0, m = 1; b != 0; j++, b >>= 1, m <<= 1) {
                        if (b & 1) {
                                p->fd = n + j;
                                if (p->fd >= nfds)
                                        goto done;
                                p->events = 0;
                                if (*in & m)
                                        p->events |= POLLRDNORM;
                                if (*out & m)
                                        p->events |= POLLWRNORM;
                                if (*ex & m)
                                        p->events |= POLLRDBAND;
                                p++;
                        }
                }
                in++;
                out++;
                ex++;
        }
done:	
	if (timeout)
		ms = (timeout->tv_usec/1000) + (timeout->tv_sec*1000);
	else ms = -1;
	if (fds) FD_ZERO(fds);
	if ((ret =  poll(filedes, pfd, ms)) > 0)
	{
		for (i=0;i < pfd; i++)
		{
			if (filedes[i].revents) 
			{
				FD_SET(filedes[i].fd, fds);
			}
		}
	}
	return ret;
#endif
}
#endif /* UNIX */
